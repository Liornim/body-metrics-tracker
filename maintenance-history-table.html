<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>转 住专转 转拽 注 </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .date-selector {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .date-selector h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .date-input {
            display: inline-block;
            position: relative;
            margin: 0 10px;
        }
        
        .date-input input {
            padding: 10px 15px;
            font-size: 16px;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }
        
        .date-display {
            padding: 10px 15px;
            font-size: 16px;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            min-width: 120px;
            text-align: center;
        }
        
        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }
        
        .maintenance-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .maintenance-table th {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .maintenance-table td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
        }
        
        .maintenance-table tr:hover {
            background-color: #f8f9fa;
        }
        
        .date-cell {
            background: #e8f5e8;
            font-weight: bold;
            color: #2e7d32;
        }
        
        .maintenance-value {
            font-weight: bold;
            color: #2e7d32;
        }
        
        .maintenance-value.low {
            color: #f44336;
        }
        
        .maintenance-value.high {
            color: #ff9800;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        
        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        
        .explanation {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        
        .explanation h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }
        
        .explanation p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        
        .export-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .export-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .export-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 5px;
            transition: all 0.3s ease;
        }
        
        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(33, 150, 243, 0.4);
        }
        
        .table-section {
            margin-bottom: 40px;
        }
        
        
        .table-section h3 {
            color: #333;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border-radius: 10px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .maintenance-table th,
            .maintenance-table td {
                padding: 8px 5px;
                font-size: 12px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1> 转 住专转 转拽 注 </h1>
            <p>爪转 7 砖 转拽 专   </p>
        </div>
        
        <div class="content">
            <div class="explanation">
                <h4>   注?</h4>
                <p><strong> 爪:</strong> 7 砖 转拽 专    (3, 5, 7, 9, 14 )</p>
                <p><strong> 砖专:</strong> 转专 专 + 6 转专 拽</p>
                <p><strong> 注:</strong>   砖 注 砖 转拽 转转</p>
                <p><strong>住:</strong> 转拽 = 拽专转 爪注转 + (专转 砖拽  7700 梅 ) - (爪注 爪注 梅 25)</p>
            </div>
            
            <div class="date-selector">
                <h3> 专 转专 专 砖</h3>
                <div class="date-input">
                    <input type="date" id="datePicker" style="opacity: 0; position: absolute; z-index: 2; width: 100%;">
                    <div id="dateDisplay" class="date-display">专 转专</div>
                </div>
                <button class="btn" onclick="calculateMaintenanceHistory()"> 爪 住专</button>
            </div>
            
            <div id="loading" class="loading" style="display: none;">
                 注 转 砖 住专转 转拽...
            </div>
            
            <div id="error" class="error" style="display: none;"></div>
            
            <div id="tableContainer" class="table-container" style="display: none;">
                <div class="table-section">
                    <h3> 转 住专转 转拽 - 7 砖 专</h3>
                    <div id="summaryTableContainer">
                        <!-- Summary table will be populated here -->
                    </div>
                </div>
                
                <div class="export-section">
                    <h3> 爪 转</h3>
                    <button class="export-btn" onclick="exportToExcel()"> 爪 -Excel</button>
                    <button class="export-btn" onclick="exportFullHistoryToExcel()"> 爪 住专 </button>
                </div>
                
                <div class="table-section">
                    <h3> 住专  -  转</h3>
                    <div id="fullHistoryTableContainer">
                        <!-- Full history table will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxm9p0ckreQ88HAqR-DZ_blJqyEhtm2GCQy_gXtvHyjXZULMdMgdWWFaIaFXfT-4ZT6/exec';
        
        // Set today's date as default
        document.addEventListener('DOMContentLoaded', function() {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            document.getElementById('datePicker').value = todayStr;
            
            // Display today's date in DD/MM/YYYY format
            const parts = todayStr.split('-');
            const formattedDate = `${parts[2]}/${parts[1]}/${parts[0]}`;
            document.getElementById('dateDisplay').textContent = formattedDate;
        });

        // Format date picker display
        document.getElementById('datePicker').addEventListener('change', function() {
            const selectedDate = this.value;
            if (selectedDate) {
                const parts = selectedDate.split('-');
                const formattedDate = `${parts[2]}/${parts[1]}/${parts[0]}`;
                document.getElementById('dateDisplay').textContent = formattedDate;
            }
        });

        // Make the display div clickable
        document.getElementById('dateDisplay').addEventListener('click', function() {
            document.getElementById('datePicker').showPicker();
        });

        async function calculateMaintenanceHistory() {
            const selectedDate = document.getElementById('datePicker').value;
            if (!selectedDate) {
                showError(' 专 转专');
                return;
            }

            try {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('error').style.display = 'none';
                document.getElementById('tableContainer').style.display = 'none';

                // Load both body metrics and nutrition data
                const [bodyMetricsResponse, nutritionResponse] = await Promise.all([
                    fetch(`${GOOGLE_SCRIPT_URL}?action=get`),
                    fetch(`${GOOGLE_SCRIPT_URL}?action=getNutrition`)
                ]);

                const bodyMetricsData = await bodyMetricsResponse.json();
                const nutritionData = await nutritionResponse.json();

                if (!bodyMetricsData.success || !nutritionData.success) {
                    showError('砖 注转 转');
                    return;
                }

                // Convert selected date to DD/MM/YYYY for comparison
                const selectedDateParts = selectedDate.split('-');
                const selectedDateFormatted = `${selectedDateParts[2]}/${selectedDateParts[1]}/${selectedDateParts[0]}`;

                // Calculate maintenance history for each window
                const windows = [3, 5, 7, 9, 14];
                const historyData = [];

                for (const windowDays of windows) {
                    const windowHistory = calculateWindowHistory(
                        bodyMetricsData.data, 
                        nutritionData.data, 
                        selectedDateFormatted, 
                        windowDays
                    );
                    historyData.push({
                        windowDays,
                        history: windowHistory
                    });
                }

                displayMaintenanceTable(historyData, selectedDateFormatted);
                displayFullHistoryTable(bodyMetricsData.data, nutritionData.data);

            } catch (error) {
                showError('砖 专 砖专转: ' + error.message);
            }
        }

        function calculateWindowHistory(bodyData, nutritionData, selectedDate, windowDays) {
            // Sort data by date (newest first)
            const sortedBodyData = [...bodyData].sort((a, b) => new Date(b[0]) - new Date(a[0]));
            const sortedNutritionData = [...nutritionData].sort((a, b) => new Date(b[0]) - new Date(a[0]));

            // Find the selected date index
            const selectedIndex = sortedBodyData.findIndex(row => row[0] === selectedDate);
            if (selectedIndex === -1) {
                console.log(`Selected date ${selectedDate} not found in body data`);
                return [];
            }

            const history = [];

            // Calculate maintenance for last 7 dates
            for (let i = 0; i < 7; i++) {
                const currentDateIndex = selectedIndex + i;
                
                // Get current window data
                const currentWindowBody = sortedBodyData.slice(currentDateIndex, currentDateIndex + windowDays);
                const currentWindowNutrition = sortedNutritionData.slice(currentDateIndex, currentDateIndex + windowDays);

                // Get previous window data
                const previousWindowBody = sortedBodyData.slice(currentDateIndex + windowDays, currentDateIndex + windowDays * 2);
                const previousWindowNutrition = sortedNutritionData.slice(currentDateIndex + windowDays, currentDateIndex + windowDays * 2);

                if (currentWindowBody.length < windowDays || previousWindowBody.length < windowDays) {
                    console.log(`Not enough data for ${windowDays}-day window at index ${currentDateIndex}`);
                    break;
                }

                // Calculate averages for current window
                const currentAvgWeight = currentWindowBody.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;
                const currentAvgCalories = currentWindowNutrition.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;
                const currentAvgSteps = currentWindowNutrition.reduce((sum, row) => sum + parseFloat(row[6]), 0) / windowDays;

                // Calculate averages for previous window
                const previousAvgWeight = previousWindowBody.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;

                // Calculate weight loss (positive = loss, negative = gain)
                const weightLoss = previousAvgWeight - currentAvgWeight;

                // Calculate real maintenance
                const weightLossCalories = (weightLoss * 7700) / windowDays;
                const stepsCalories = currentAvgSteps / 25;
                const realMaintenance = currentAvgCalories + weightLossCalories - stepsCalories;

                history.push({
                    date: currentWindowBody[0][0], // First date in current window
                    maintenance: realMaintenance.toFixed(0),
                    weightLoss: weightLoss.toFixed(2),
                    avgCalories: currentAvgCalories.toFixed(0),
                    avgSteps: currentAvgSteps.toFixed(0)
                });
            }

            return history;
        }

        function displayMaintenanceTable(historyData, selectedDate) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('tableContainer').style.display = 'block';

            const tableContainer = document.getElementById('summaryTableContainer');
            
            // Create table
            const table = document.createElement('table');
            table.className = 'maintenance-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const dateHeader = document.createElement('th');
            dateHeader.textContent = '转专';
            dateHeader.style.minWidth = '100px';
            headerRow.appendChild(dateHeader);
            
            historyData.forEach(windowData => {
                const th = document.createElement('th');
                th.textContent = `${windowData.windowDays} `;
                th.style.minWidth = '120px';
                headerRow.appendChild(th);
            });
            
            // Add average column header
            const avgHeader = document.createElement('th');
            avgHeader.textContent = '爪注';
            avgHeader.style.minWidth = '100px';
            avgHeader.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
            headerRow.appendChild(avgHeader);
            
            // Add trimmed average column header
            const trimmedAvgHeader = document.createElement('th');
            trimmedAvgHeader.textContent = '爪注  拽爪';
            trimmedAvgHeader.style.minWidth = '120px';
            trimmedAvgHeader.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
            headerRow.appendChild(trimmedAvgHeader);
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            
            // Get the maximum number of history entries
            const maxHistoryLength = Math.max(...historyData.map(w => w.history.length));
            
            // Calculate column averages
            const columnAverages = [];
            for (let j = 0; j < historyData.length; j++) {
                const windowData = historyData[j];
                const validValues = windowData.history.filter(h => h).map(h => parseFloat(h.maintenance));
                const avg = validValues.length > 0 ? validValues.reduce((sum, val) => sum + val, 0) / validValues.length : 0;
                columnAverages.push(avg);
            }
            
            for (let i = 0; i < maxHistoryLength; i++) {
                const row = document.createElement('tr');
                
                // Date cell
                const dateCell = document.createElement('td');
                dateCell.className = 'date-cell';
                if (historyData[0].history[i]) {
                    dateCell.textContent = historyData[0].history[i].date;
                }
                row.appendChild(dateCell);
                
                // Calculate row average and trimmed average
                let rowSum = 0;
                let rowCount = 0;
                const rowValues = [];
                
                // Maintenance cells for each window
                historyData.forEach((windowData, j) => {
                    const cell = document.createElement('td');
                    cell.className = 'maintenance-value';
                    
                    if (windowData.history[i]) {
                        const maintenance = parseFloat(windowData.history[i].maintenance);
                        cell.textContent = maintenance;
                        
                        // Add to row average calculation
                        rowSum += maintenance;
                        rowCount++;
                        rowValues.push(maintenance);
                        
                        // Color coding based on maintenance level
                        if (maintenance < 1500) {
                            cell.classList.add('low');
                        } else if (maintenance > 2500) {
                            cell.classList.add('high');
                        }
                    } else {
                        cell.textContent = '-';
                        cell.style.color = '#ccc';
                    }
                    
                    row.appendChild(cell);
                });
                
                // Add row average cell
                const avgCell = document.createElement('td');
                avgCell.className = 'maintenance-value';
                avgCell.style.background = '#fff3e0';
                avgCell.style.fontWeight = 'bold';
                if (rowCount > 0) {
                    const rowAvg = rowSum / rowCount;
                    avgCell.textContent = rowAvg.toFixed(0);
                    
                    // Color coding for row average
                    if (rowAvg < 1500) {
                        avgCell.classList.add('low');
                    } else if (rowAvg > 2500) {
                        avgCell.classList.add('high');
                    }
                } else {
                    avgCell.textContent = '-';
                    avgCell.style.color = '#ccc';
                }
                row.appendChild(avgCell);
                
                // Add trimmed average cell (excluding highest and lowest values)
                const trimmedAvgCell = document.createElement('td');
                trimmedAvgCell.className = 'maintenance-value';
                trimmedAvgCell.style.background = '#e8f5e8';
                trimmedAvgCell.style.fontWeight = 'bold';
                
                if (rowValues.length >= 3) {
                    // Sort values and remove highest and lowest
                    const sortedValues = [...rowValues].sort((a, b) => a - b);
                    const trimmedValues = sortedValues.slice(1, -1); // Remove first (lowest) and last (highest)
                    const trimmedAvg = trimmedValues.reduce((sum, val) => sum + val, 0) / trimmedValues.length;
                    trimmedAvgCell.textContent = trimmedAvg.toFixed(0);
                    
                    // Color coding for trimmed average
                    if (trimmedAvg < 1500) {
                        trimmedAvgCell.classList.add('low');
                    } else if (trimmedAvg > 2500) {
                        trimmedAvgCell.classList.add('high');
                    }
                } else {
                    trimmedAvgCell.textContent = '-';
                    trimmedAvgCell.style.color = '#ccc';
                }
                row.appendChild(trimmedAvgCell);
                
                tbody.appendChild(row);
            }
            
            // Add average row
            const avgRow = document.createElement('tr');
            avgRow.style.background = '#e8f5e8';
            
            const avgLabelCell = document.createElement('td');
            avgLabelCell.textContent = '爪注';
            avgLabelCell.style.fontWeight = 'bold';
            avgLabelCell.style.background = '#fff3e0';
            avgRow.appendChild(avgLabelCell);
            
            // Add column averages
            historyData.forEach((windowData, j) => {
                const avgCell = document.createElement('td');
                avgCell.className = 'maintenance-value';
                avgCell.style.fontWeight = 'bold';
                avgCell.style.background = '#fff3e0';
                avgCell.textContent = columnAverages[j].toFixed(0);
                
                // Color coding for column average
                if (columnAverages[j] < 1500) {
                    avgCell.classList.add('low');
                } else if (columnAverages[j] > 2500) {
                    avgCell.classList.add('high');
                }
                
                avgRow.appendChild(avgCell);
            });
            
            // Add overall average (average of all averages)
            const overallAvgCell = document.createElement('td');
            overallAvgCell.className = 'maintenance-value';
            overallAvgCell.style.fontWeight = 'bold';
            overallAvgCell.style.background = '#ffeb3b';
            overallAvgCell.style.fontSize = '16px';
            
            const validColumnAverages = columnAverages.filter(avg => avg > 0);
            const overallAvg = validColumnAverages.length > 0 ? 
                validColumnAverages.reduce((sum, avg) => sum + avg, 0) / validColumnAverages.length : 0;
            overallAvgCell.textContent = overallAvg.toFixed(0);
            
            // Color coding for overall average
            if (overallAvg < 1500) {
                overallAvgCell.classList.add('low');
            } else if (overallAvg > 2500) {
                overallAvgCell.classList.add('high');
            }
            
            avgRow.appendChild(overallAvgCell);
            
            // Add overall trimmed average (excluding highest and lowest column averages)
            const overallTrimmedAvgCell = document.createElement('td');
            overallTrimmedAvgCell.className = 'maintenance-value';
            overallTrimmedAvgCell.style.fontWeight = 'bold';
            overallTrimmedAvgCell.style.background = '#c8e6c9';
            overallTrimmedAvgCell.style.fontSize = '16px';
            
            if (validColumnAverages.length >= 3) {
                const sortedColumnAverages = [...validColumnAverages].sort((a, b) => a - b);
                const trimmedColumnAverages = sortedColumnAverages.slice(1, -1); // Remove highest and lowest
                const overallTrimmedAvg = trimmedColumnAverages.reduce((sum, avg) => sum + avg, 0) / trimmedColumnAverages.length;
                overallTrimmedAvgCell.textContent = overallTrimmedAvg.toFixed(0);
                
                // Color coding for overall trimmed average
                if (overallTrimmedAvg < 1500) {
                    overallTrimmedAvgCell.classList.add('low');
                } else if (overallTrimmedAvg > 2500) {
                    overallTrimmedAvgCell.classList.add('high');
                }
            } else {
                overallTrimmedAvgCell.textContent = '-';
                overallTrimmedAvgCell.style.color = '#ccc';
            }
            
            avgRow.appendChild(overallTrimmedAvgCell);
            tbody.appendChild(avgRow);
            
            table.appendChild(tbody);
            tableContainer.innerHTML = '';
            tableContainer.appendChild(table);
        }

        function displayFullHistoryTable(bodyData, nutritionData) {
            const tableContainer = document.getElementById('fullHistoryTableContainer');
            
            // Sort data by date (newest first) - handle DD/MM/YYYY format
            const parseDate = (dateStr) => {
                const parts = dateStr.split('/');
                return new Date(parts[2], parts[1] - 1, parts[0]);
            };
            
            const sortedBodyData = [...bodyData].sort((a, b) => parseDate(b[0]) - parseDate(a[0]));
            const sortedNutritionData = [...nutritionData].sort((a, b) => parseDate(b[0]) - parseDate(a[0]));
            
            // Create table
            const table = document.createElement('table');
            table.className = 'maintenance-table';
            
            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            const headers = ['转专', '3 ', '5 ', '7 ', '9 ', '14 ', '爪注', '爪注  拽爪'];
            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                th.style.minWidth = '100px';
                if (headerText === '爪注') {
                    th.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
                } else if (headerText === '爪注  拽爪') {
                    th.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                }
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body
            const tbody = document.createElement('tbody');
            
            // Calculate maintenance for all available dates
            const windows = [3, 5, 7, 9, 14];
            const allHistoryData = [];
            
            // Get all available dates from the beginning of data
            // We need at least 14 days of previous data for the 14-day window calculation
            const maxWindowDays = Math.max(...windows);
            const totalDataLength = sortedBodyData.length;
            
            const startIndex = maxWindowDays;
            const endIndex = totalDataLength;
            
            for (let i = endIndex - 1; i >= startIndex; i--) {
                const currentDateIndex = i;
                const currentDate = sortedBodyData[currentDateIndex][0];
                
                const rowData = {
                    date: currentDate,
                    maintenance: []
                };
                
                let rowSum = 0;
                let rowCount = 0;
                const rowValues = [];
                
                // Calculate maintenance for each window
                windows.forEach(windowDays => {
                    // Current window: from current date going forward
                    const currentWindowBody = sortedBodyData.slice(currentDateIndex, currentDateIndex + windowDays);
                    const currentWindowNutrition = sortedNutritionData.slice(currentDateIndex, currentDateIndex + windowDays);
                    
                    // Previous window: the window before the current window
                    const previousWindowBody = sortedBodyData.slice(currentDateIndex + windowDays, currentDateIndex + windowDays * 2);
                    const previousWindowNutrition = sortedNutritionData.slice(currentDateIndex + windowDays, currentDateIndex + windowDays * 2);
                    
                    if (currentWindowBody.length >= windowDays && previousWindowBody.length >= windowDays) {
                        // Calculate averages
                        const currentAvgWeight = currentWindowBody.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;
                        const currentAvgCalories = currentWindowNutrition.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;
                        const currentAvgSteps = currentWindowNutrition.reduce((sum, row) => sum + parseFloat(row[6]), 0) / windowDays;
                        const previousAvgWeight = previousWindowBody.reduce((sum, row) => sum + parseFloat(row[1]), 0) / windowDays;
                        
                        // Calculate maintenance
                        const weightLoss = previousAvgWeight - currentAvgWeight;
                        const weightLossCalories = (weightLoss * 7700) / windowDays;
                        const stepsCalories = currentAvgSteps / 25;
                        const realMaintenance = currentAvgCalories + weightLossCalories - stepsCalories;
                        
                        rowData.maintenance.push(realMaintenance);
                        rowSum += realMaintenance;
                        rowCount++;
                        rowValues.push(realMaintenance);
                    } else {
                        rowData.maintenance.push(null);
                    }
                });
                
                // Calculate row average
                rowData.average = rowCount > 0 ? rowSum / rowCount : null;
                
                // Calculate trimmed average (excluding highest and lowest values)
                if (rowValues.length >= 3) {
                    const sortedValues = [...rowValues].sort((a, b) => a - b);
                    const trimmedValues = sortedValues.slice(1, -1); // Remove first (lowest) and last (highest)
                    rowData.trimmedAverage = trimmedValues.reduce((sum, val) => sum + val, 0) / trimmedValues.length;
                } else {
                    rowData.trimmedAverage = null;
                }
                
                allHistoryData.push(rowData);
            }
            
            // Display the data
            allHistoryData.forEach((rowData, index) => {
                const row = document.createElement('tr');
                
                // Date cell
                const dateCell = document.createElement('td');
                dateCell.className = 'date-cell';
                dateCell.textContent = rowData.date;
                row.appendChild(dateCell);
                
                // Maintenance cells
                rowData.maintenance.forEach((maintenance, index) => {
                    const cell = document.createElement('td');
                    cell.className = 'maintenance-value';
                    
                    if (maintenance !== null) {
                        cell.textContent = maintenance.toFixed(0);
                        
                        // Color coding
                        if (maintenance < 1500) {
                            cell.classList.add('low');
                        } else if (maintenance > 2500) {
                            cell.classList.add('high');
                        }
                    } else {
                        cell.textContent = '-';
                        cell.style.color = '#ccc';
                    }
                    
                    row.appendChild(cell);
                });
                
                // Average cell
                const avgCell = document.createElement('td');
                avgCell.className = 'maintenance-value';
                avgCell.style.background = '#fff3e0';
                avgCell.style.fontWeight = 'bold';
                
                if (rowData.average !== null) {
                    avgCell.textContent = rowData.average.toFixed(0);
                    
                    if (rowData.average < 1500) {
                        avgCell.classList.add('low');
                    } else if (rowData.average > 2500) {
                        avgCell.classList.add('high');
                    }
                } else {
                    avgCell.textContent = '-';
                    avgCell.style.color = '#ccc';
                }
                
                row.appendChild(avgCell);
                
                // Trimmed average cell
                const trimmedAvgCell = document.createElement('td');
                trimmedAvgCell.className = 'maintenance-value';
                trimmedAvgCell.style.background = '#e8f5e8';
                trimmedAvgCell.style.fontWeight = 'bold';
                
                if (rowData.trimmedAverage !== null) {
                    trimmedAvgCell.textContent = rowData.trimmedAverage.toFixed(0);
                    
                    if (rowData.trimmedAverage < 1500) {
                        trimmedAvgCell.classList.add('low');
                    } else if (rowData.trimmedAverage > 2500) {
                        trimmedAvgCell.classList.add('high');
                    }
                } else {
                    trimmedAvgCell.textContent = '-';
                    trimmedAvgCell.style.color = '#ccc';
                }
                
                row.appendChild(trimmedAvgCell);
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            tableContainer.innerHTML = '';
            tableContainer.appendChild(table);
            
            // Store data for Excel export
            window.fullHistoryData = allHistoryData;
        }
        
        function exportToExcel() {
            const table = document.querySelector('#summaryTableContainer table');
            if (!table) {
                alert(' 转 爪');
                return;
            }
            
            // Create a new workbook
            const wb = XLSX.utils.book_new();
            
            // Convert table to worksheet
            const ws = XLSX.utils.table_to_sheet(table);
            
            // Set number format for maintenance values (columns B-G)
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let row = range.s.r + 1; row <= range.e.r; row++) {
                for (let col = range.s.c + 1; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({r: row, c: col});
                    if (ws[cellAddress] && ws[cellAddress].v && !isNaN(ws[cellAddress].v)) {
                        ws[cellAddress].z = '0'; // Number format
                    }
                }
            }
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, '住专转 转拽');
            
            // Save the file
            XLSX.writeFile(wb, '住专转_转拽_住.xlsx');
        }
        
        function exportFullHistoryToExcel() {
            if (!window.fullHistoryData || window.fullHistoryData.length === 0) {
                alert(' 转 爪');
                return;
            }
            
            // Create a new workbook
            const wb = XLSX.utils.book_new();
            
            // Prepare data for Excel with proper number formatting
            const excelData = [];
            
            // Add headers
            excelData.push(['转专', '3 ', '5 ', '7 ', '9 ', '14 ', '爪注', '爪注  拽爪']);
            
            // Add data rows
            window.fullHistoryData.forEach(rowData => {
                const row = [rowData.date];
                rowData.maintenance.forEach(maintenance => {
                    row.push(maintenance !== null ? parseFloat(maintenance.toFixed(0)) : '');
                });
                row.push(rowData.average !== null ? parseFloat(rowData.average.toFixed(0)) : '');
                row.push(rowData.trimmedAverage !== null ? parseFloat(rowData.trimmedAverage.toFixed(0)) : '');
                excelData.push(row);
            });
            
            // Create worksheet
            const ws = XLSX.utils.aoa_to_sheet(excelData);
            
            // Set number format for maintenance values (columns B-G)
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let row = range.s.r + 1; row <= range.e.r; row++) {
                for (let col = range.s.c + 1; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({r: row, c: col});
                    if (ws[cellAddress] && ws[cellAddress].v && !isNaN(ws[cellAddress].v)) {
                        ws[cellAddress].z = '0'; // Number format
                    }
                }
            }
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, '住专 ');
            
            // Save the file
            XLSX.writeFile(wb, '住专转_转拽_.xlsx');
        }
        
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = message;
        }
    </script>
</body>
</html>
